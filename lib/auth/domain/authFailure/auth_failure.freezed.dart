// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AuthFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelByUser,
    required TResult Function() serveError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidCombination,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelByUser value) cancelByUser,
    required TResult Function(_ServerError value) serveError,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_InvalidCombination value) invalidCombination,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res> implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  final AuthFailure _value;
  // ignore: unused_field
  final $Res Function(AuthFailure) _then;
}

/// @nodoc
abstract class _$$_CancelByUserCopyWith<$Res> {
  factory _$$_CancelByUserCopyWith(
          _$_CancelByUser value, $Res Function(_$_CancelByUser) then) =
      __$$_CancelByUserCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CancelByUserCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$$_CancelByUserCopyWith<$Res> {
  __$$_CancelByUserCopyWithImpl(
      _$_CancelByUser _value, $Res Function(_$_CancelByUser) _then)
      : super(_value, (v) => _then(v as _$_CancelByUser));

  @override
  _$_CancelByUser get _value => super._value as _$_CancelByUser;
}

/// @nodoc

class _$_CancelByUser extends _CancelByUser {
  const _$_CancelByUser() : super._();

  @override
  String toString() {
    return 'AuthFailure.cancelByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_CancelByUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelByUser,
    required TResult Function() serveError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidCombination,
  }) {
    return cancelByUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
  }) {
    return cancelByUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
    required TResult orElse(),
  }) {
    if (cancelByUser != null) {
      return cancelByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelByUser value) cancelByUser,
    required TResult Function(_ServerError value) serveError,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_InvalidCombination value) invalidCombination,
  }) {
    return cancelByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
  }) {
    return cancelByUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
    required TResult orElse(),
  }) {
    if (cancelByUser != null) {
      return cancelByUser(this);
    }
    return orElse();
  }
}

abstract class _CancelByUser extends AuthFailure {
  const factory _CancelByUser() = _$_CancelByUser;
  const _CancelByUser._() : super._();
}

/// @nodoc
abstract class _$$_ServerErrorCopyWith<$Res> {
  factory _$$_ServerErrorCopyWith(
          _$_ServerError value, $Res Function(_$_ServerError) then) =
      __$$_ServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ServerErrorCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$$_ServerErrorCopyWith<$Res> {
  __$$_ServerErrorCopyWithImpl(
      _$_ServerError _value, $Res Function(_$_ServerError) _then)
      : super(_value, (v) => _then(v as _$_ServerError));

  @override
  _$_ServerError get _value => super._value as _$_ServerError;
}

/// @nodoc

class _$_ServerError extends _ServerError {
  const _$_ServerError() : super._();

  @override
  String toString() {
    return 'AuthFailure.serveError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelByUser,
    required TResult Function() serveError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidCombination,
  }) {
    return serveError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
  }) {
    return serveError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
    required TResult orElse(),
  }) {
    if (serveError != null) {
      return serveError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelByUser value) cancelByUser,
    required TResult Function(_ServerError value) serveError,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_InvalidCombination value) invalidCombination,
  }) {
    return serveError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
  }) {
    return serveError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
    required TResult orElse(),
  }) {
    if (serveError != null) {
      return serveError(this);
    }
    return orElse();
  }
}

abstract class _ServerError extends AuthFailure {
  const factory _ServerError() = _$_ServerError;
  const _ServerError._() : super._();
}

/// @nodoc
abstract class _$$_EmailAlreadyInUseCopyWith<$Res> {
  factory _$$_EmailAlreadyInUseCopyWith(_$_EmailAlreadyInUse value,
          $Res Function(_$_EmailAlreadyInUse) then) =
      __$$_EmailAlreadyInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EmailAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$$_EmailAlreadyInUseCopyWith<$Res> {
  __$$_EmailAlreadyInUseCopyWithImpl(
      _$_EmailAlreadyInUse _value, $Res Function(_$_EmailAlreadyInUse) _then)
      : super(_value, (v) => _then(v as _$_EmailAlreadyInUse));

  @override
  _$_EmailAlreadyInUse get _value => super._value as _$_EmailAlreadyInUse;
}

/// @nodoc

class _$_EmailAlreadyInUse extends _EmailAlreadyInUse {
  const _$_EmailAlreadyInUse() : super._();

  @override
  String toString() {
    return 'AuthFailure.emailAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_EmailAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelByUser,
    required TResult Function() serveError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidCombination,
  }) {
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
  }) {
    return emailAlreadyInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelByUser value) cancelByUser,
    required TResult Function(_ServerError value) serveError,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_InvalidCombination value) invalidCombination,
  }) {
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
  }) {
    return emailAlreadyInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
    required TResult orElse(),
  }) {
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _EmailAlreadyInUse extends AuthFailure {
  const factory _EmailAlreadyInUse() = _$_EmailAlreadyInUse;
  const _EmailAlreadyInUse._() : super._();
}

/// @nodoc
abstract class _$$_InvalidCombinationCopyWith<$Res> {
  factory _$$_InvalidCombinationCopyWith(_$_InvalidCombination value,
          $Res Function(_$_InvalidCombination) then) =
      __$$_InvalidCombinationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InvalidCombinationCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$$_InvalidCombinationCopyWith<$Res> {
  __$$_InvalidCombinationCopyWithImpl(
      _$_InvalidCombination _value, $Res Function(_$_InvalidCombination) _then)
      : super(_value, (v) => _then(v as _$_InvalidCombination));

  @override
  _$_InvalidCombination get _value => super._value as _$_InvalidCombination;
}

/// @nodoc

class _$_InvalidCombination extends _InvalidCombination {
  const _$_InvalidCombination() : super._();

  @override
  String toString() {
    return 'AuthFailure.invalidCombination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InvalidCombination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() cancelByUser,
    required TResult Function() serveError,
    required TResult Function() emailAlreadyInUse,
    required TResult Function() invalidCombination,
  }) {
    return invalidCombination();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
  }) {
    return invalidCombination?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? cancelByUser,
    TResult Function()? serveError,
    TResult Function()? emailAlreadyInUse,
    TResult Function()? invalidCombination,
    required TResult orElse(),
  }) {
    if (invalidCombination != null) {
      return invalidCombination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_CancelByUser value) cancelByUser,
    required TResult Function(_ServerError value) serveError,
    required TResult Function(_EmailAlreadyInUse value) emailAlreadyInUse,
    required TResult Function(_InvalidCombination value) invalidCombination,
  }) {
    return invalidCombination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
  }) {
    return invalidCombination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_CancelByUser value)? cancelByUser,
    TResult Function(_ServerError value)? serveError,
    TResult Function(_EmailAlreadyInUse value)? emailAlreadyInUse,
    TResult Function(_InvalidCombination value)? invalidCombination,
    required TResult orElse(),
  }) {
    if (invalidCombination != null) {
      return invalidCombination(this);
    }
    return orElse();
  }
}

abstract class _InvalidCombination extends AuthFailure {
  const factory _InvalidCombination() = _$_InvalidCombination;
  const _InvalidCombination._() : super._();
}
